Задания.

1. Прочитать данные из файла, заменить вхождения одной последовательности (исходной на заменяющую) байт на другую, результат записать в другой файл. Файл и последовательности произвольного размера и произвольного содержимого.
Запрещено считывать из файла каждый байт более одного раза.
Имена файлов и последовательности (исходную и заменяющую) получать из аргументов командной строки.
Чтение из файла осуществлять блоками размером 512 байт (для работы с файлами использовать функции fopen ,fread, fwrite, fclose).
Пример. Если в тексте "adfkasddkjadfkdaqwed" заменить "ad" на "12345", то получим "12345fkasddkj12345fkdaqwed".

Условия для оценки 3
1) Можно считать, что размер исходной последовательности не больше 512 байт.
2) В памяти нельзя хранить из файла данных одновременно больше чем 1024 байта.

Условия для оценки 4
1) В памяти нельзя хранить из файла данных одновременно больше чем 512 байт.




2. Программа вывода содержимого файла в шестнадцатиричном виде.

Условия для оценки 3.

Программа должна поддерживать опции командной строки (передаются в любом порядке):
-i file_name	имя выводимого файла
-o offset		смещение от начала файла, с которого выводится содержимое (если не задано, то выводить с начала файла)
-l size			количество выводимых из файла байт (если не задано, то выводить всё)
-g byte|word|dword	какими кусочками выводить данные: 1 байт, 2 байта, 4 байта (если не задано, то 1 байт)
-n count		количество кусочков, выводимых в одной строке (если не задано, то 16)

В каждой строке программа должна выводить смещение от начала файла, указанное количество кусочков информации в шестнадцатиричном виде. Если кусочек равен байту (т.е. опция -n byte), то в конце строки после вывода данных в шестнадцатиричном виде выводить их же в символьном виде (для каких это возможно).

Осуществлять преобразования байт файла в шестнадцатиричные символы самостоятельно. Т.е. с помощью printf можно выводить только символы (с помощью %c), соответствующие байтам содержимого файла (которые необходимо самостоятельно перевести в символы). Смещение можно выводить с помощью printf в виде числа (через %x).

Для разбора аргументов командной строки использовать функцию getopt. Настроенный шаблон для задания прилагается (template\2).

Пример использования.
Пусть содержимое файла file (последовательность байт в шестнадцатиричном виде):
0x10 0x11 0x12 0x13 0xFA 0xFB 0xFC 0xFD 0x00 0x20 0x30 0x40 0x41 0x42 0x31 0x32 0x33 0x34

./prog -i file
00000000  10 11 12 13 FA FB FC FD 00 20 30 40 41 42 31 32 | ........ 0@AB12
00000010  33 34                                           | 34

./prog -o 2 -g dword -n 2 -l 12 -i file
00000002  FBFA1312 2000FDFC
0000000A  42414030

./prog -o 2 -l 11 -g dword -n 2 -i file
00000002  FBFA1312 2000FDFC
0000000A  00414030


Условия для оценки 4.
Дополнительно поддерживать опцию
-f format_str	указание форматной строки, определяющей формат вывода каждой строки.
Форматная строка состоит из обычных символов, спецсимволов и спецификаторов.
Обычными символами считаются все символы, которые не являются спецсимволами или частью спецификатора.
Спецсимволами являются символы '\' и '%', которые меняют интерпретацию следующего за ними символа. Поддерживать следующие последовательности:
"\n" - байт перевода строки (0x0A).
"\r" - байт возврата каретки (0x0D).
"\t" - байт табуляции (0x09).
"\\" - символ '\'.
Спецификаторы соответствуют выводимым кусочкам (их количество в строке и размер задаётся параметрами -n, -g) файла.
Спецификаторы имеют вид:
%i - индекс текущей строки
%n - смещение текущей строки
%ix - вывод i-го кусочка в шестнадцатиричном виде
%ic - вывод i-го кусочка в символьном виде (1, 2 или 4 символа в зависимости от размера кусочка)

./prog -i file -f "%i %n %0x %1x %2x %3x %4x %5x %6x %7x %8x %9x %10x %11x %12x %13x %14x %15x | %0c%1c%2c%3c%4c%5c%6c%7c%8c%9c%10c%11c%12c%13c%14c%15c\n"
0 00000000 10 11 12 13 FA FB FC FD 00 20 30 40 41 42 31 32 | ........ 0@ABC12
1 00000010 33 34                                           | 34

./prog -i file -o 2 -g word -n 3 -f "%i x0 = %0x\t\tx2 = %2x(%2с)\n"
0 x0 = 1312		x2 = FDFC(..)
1 x0 = 2000		x2 = 4241(AB)
2 x0 = 3231		x2 = 0000(..)




3. Реализовать функции преобразования из числа в строку и из строки в число.

Условия для оценки 3.

При реализации алгоритмов преобразований не должны использоваться никакие библиотечные функции. Нельзя использовать типы данных размером больше int (например, long long).

1) Функция 
int strtoi (IN const char *str, OUT char **p, OUT int *ret)
анализирует строку str, преобразует её в число типа int, которое возвращается по указателю ret.
Возвращаемые значения:
0 - успех
1 - недопустимые символы в строке (не соответствующие алфавиту)
2 - переполнение int (слишком большое или слишком маленькое число)

Функция должна проверять корректность символов в строке. По указателю p (если он не нулевой) возвращается указатель на первый символ строки, содержащий некорректное значение.

Ошибкой считается случай задания строкой числа (до нулевого символа или до первого некорректного символа), не помещающегося в int.

Систему счисления необходимо определять из вида строки: начинается с префикса "Yx", где Y \in {2, 3 ..., 9, A, B, ..., Z, a, b, ..., z, !}. Если префикса нет, то десятичная.
Y	система счисления
2	двоичная
3	троичная
...
A	деcятичная
B	одиндцатиричная
...
Z	35-ричная
a	36-ричная
...
z	61-ричная
!	62-ричная
Перед префиксом возможен знак минуса.

'0' -> 0
'9' -> 9
'A' -> 10 = 'A' - 'A' + 10
'B' -> 11 =	'B' - 'A' + 10
'C' -> 11 =	'C' - 'A' + 10
...
'a' -> 36 = 'a' - 'a' + 36
'b' -> 37 = 'b' - 'a' + 36
...

Пример 1.
char *p;
int ret;
str = "2x010101201";
i = strtoi (str, &p, &ret);	-> i = 1, p = &str[8]

Пример 2.
char *p;
int ret;
str = "Gx10F";
i = strtoi (str, &p, &ret);	-> i = 0, ret = 271(0x10F, b100001111)


2) Функция
int my_itoa (char *buf, int bufSize, int value, int p)
переводит переданное число value в строку символов в p-ичной системе счисления, которую записывает в буфер buf размером bufSize. Возвращает количество записанных в буфер символов (не больше bufSize). Если аргумент buf равен нулю, то необходимо подсчитать необходимый размер буфера и вернуть его. Если размера буфера не хватает, то возвращать 0.

Написать программу, демонстрирующую работу этих функций.




4. Написать программу генерации случайных паролей.

Условия для оценки 3.

Программа должна самостоятельно обрабатывать аргументы командной строки и интепретировать следующие опции:
-m1	минимальная длина пароля
-m2	максимальная длина пароля
-n  длина пароля
-c  количество паролей
-a	алфавит символов
-C [aADS]	набор символов (указывается один или несколько символов из множества {a, A, D, S}), a - маленькие латинские символы, A - большие латинские символы, D - цифры, S - спецсимволы.
Проверять корректность опций и аргументов опций (одни и те же опции не должны повторяться, в качестве длины должна передаваться числовая строка и т.д.). В случае ошибки выводим соответсвующее сообщение. Опции могут передаваться в произвольном порядке. Могут встречаться другие опции, которые следует игнорировать. Если есть опция -m1 должна быть опция -m2. Опции -m1,-m2 и -n не совместимы вместе (выдавать соответствующее сообщение). Опции -a и -C не совместимы вместе (выдавать соответствующее сообщение).
Пример передачи корректных опций:
# generate.exe -s -m1 10 -i -m2 20 -C aD
# generate.exe -m3 -n 10 -a 123456
# generate.exe -m3 -n 10 -a -m2
Примеры ошибок
# generate.exe -m3 -n ab -a 123456
# generate.exe -m3 -n 10 -m1 1 -m2 10
# generate.exe -m3 -n 10 -a 123456 -C a
# generate.exe -s -m1 10 -i -m2 20 -C aDa
# generate.exe -s -m1 10 -i -m2 20 -C


Условия для оценки 4.

Дополнительно предусмотреть способ передачи через аргументы (завести какую-нибудь ещё опцию) вероятности появления символов в пароле. Если набор символов задается через опцию -C, то для каждого из указанных символов aADS указывать вероятность (это будет вероятность выбора символа из этого множества). Если набор задается через опцию -a, то вероятность должна указываться для отдельных символов алфавита. Если для каких-то символов или букв aADS вероятность не указана, то оставшуюся вероятность равномерно делить между оставшимися символами алфавита (для опции -a) или множествами символов (для опции -C).

